# ********RoostGPT********
"""
Test generated by RoostGPT for test java-customannotation-test using AI Type  and AI Model 

ROOST_METHOD_HASH=calculator_9ebd2df6b3
ROOST_METHOD_SIG_HASH=calculator_ad84dc0779


**Scenario 1: Basic Addition Operation**
Details:
  TestName: test_calculator_addition
  Description: Verify that the calculator correctly performs addition when the '+' operation is specified.
Execution:
  Arrange: Initialize two numbers, num1 and num2.
  Act: Call calculator(num1, num2, '+').
  Assert: Check that the result is equal to the sum of num1 and num2.
Validation:
  This test ensures that the calculator delegates to the addition function correctly and handles the '+' operation as expected, adhering to the basic arithmetic rules and function specifications.

**Scenario 2: Basic Subtraction Operation**
Details:
  TestName: test_calculator_subtraction
  Description: Verify that the calculator correctly performs subtraction when the '-' operation is specified.
Execution:
  Arrange: Initialize two numbers, num1 and num2.
  Act: Call calculator(num1, num2, '-').
  Assert: Check that the result is equal to the difference between num1 and num2.
Validation:
  This test checks that subtraction is handled correctly, ensuring the calculator's capability to manage negative results and comply with standard arithmetic subtraction rules.

**Scenario 3: Basic Multiplication Operation**
Details:
  TestName: test_calculator_multiplication
  Description: Verify that the calculator correctly performs multiplication when the '*' operation is specified.
Execution:
  Arrange: Initialize two numbers, num1 and num2.
  Act: Call calculator(num1, num2, '*').
  Assert: Check that the result is equal to the product of num1 and num2.
Validation:
  This test verifies the multiplication functionality, crucial for ensuring the calculator can handle both positive and negative numbers, and zero, reflecting accurate arithmetic operations.

**Scenario 4: Basic Division Operation**
Details:
  TestName: test_calculator_division
  Description: Verify that the calculator correctly performs division when the '/' operation is specified.
Execution:
  Arrange: Initialize two numbers, num1 and num2 where num2 is not zero.
  Act: Call calculator(num1, num2, '/').
  Assert: Check that the result is equal to the quotient of num1 divided by num2.
Validation:
  This test ensures that division operations are handled correctly, especially verifying that the function does not allow division by zero, thus maintaining mathematical accuracy and preventing runtime errors.

**Scenario 5: Division by Zero**
Details:
  TestName: test_calculator_division_by_zero
  Description: Verify that the calculator handles division by zero appropriately.
Execution:
  Arrange: Initialize num1 and set num2 to 0.
  Act: Call calculator(num1, num2, '/').
  Assert: Check that the result is "Cannot divide by zero".
Validation:
  This test is critical for ensuring that the calculator application provides a user-friendly error message instead of raising an exception, thus enhancing the robustness and reliability of the application.

**Scenario 6: Invalid Operation**
Details:
  TestName: test_calculator_invalid_operation
  Description: Verify that the calculator returns an error message when an invalid operation is passed.
Execution:
  Arrange: Initialize two numbers, num1 and num2.
  Act: Call calculator(num1, num2, 'invalid_operation').
  Assert: Check that the result is "Invalid operation".
Validation:
  This test ensures that the calculator handles unknown operations gracefully by informing the user of the invalid operation, thus maintaining usability and preventing undefined behaviors.

**Scenario 7: Zero Multiplication**
Details:
  TestName: test_calculator_zero_multiplication
  Description: Test multiplication by zero to ensure it returns zero.
Execution:
  Arrange: Initialize num1 as any number and num2 as 0.
  Act: Call calculator(num1, num2, '*').
  Assert: Check that the result is 0.
Validation:
  This scenario validates the principle that any number multiplied by zero is zero, ensuring the calculator's accuracy in edge cases involving zero.

These scenarios provide a comprehensive test suite for the calculator function, ensuring that all operations are handled correctly and that the function behaves as expected in both normal and edge cases.
"""

# ********RoostGPT********
import unittest
from calc import calculator

class Test_CalcCalculator(unittest.TestCase):

    def test_calculator_addition(self):
        # Arrange
        num1, num2 = 5, 3
        expected_result = num1 + num2
        
        # Act
        result = calculator(num1, num2, '+')
        
        # Assert
        self.assertEqual(result, expected_result)

    def test_calculator_subtraction(self):
        # Arrange
        num1, num2 = 10, 8
        expected_result = num1 - num2
        
        # Act
        result = calculator(num1, num2, '-')
        
        # Assert
        self.assertEqual(result, expected_result)

    def test_calculator_multiplication(self):
        # Arrange
        num1, num2 = 4, 6
        expected_result = num1 * num2
        
        # Act
        result = calculator(num1, num2, '*')
        
        # Assert
        self.assertEqual(result, expected_result)

    def test_calculator_division(self):
        # Arrange
        num1, num2 = 20, 5
        expected_result = num1 / num2
        
        # Act
        result = calculator(num1, num2, '/')
        
        # Assert
        self.assertEqual(result, expected_result)

    def test_calculator_division_by_zero(self):
        # Arrange
        num1, num2 = 10, 0
        expected_result = "Cannot divide by zero"
        
        # Act
        result = calculator(num1, num2, '/')
        
        # Assert
        self.assertEqual(result, expected_result)

    def test_calculator_invalid_operation(self):
        # Arrange
        num1, num2 = 15, 5
        
        # Act
        result = calculator(num1, num2, 'invalid_operation')
        
        # Assert
        self.assertEqual(result, "Invalid operation")

    def test_calculator_zero_multiplication(self):
        # Arrange
        num1, num2 = 100, 0
        expected_result = 0
        
        # Act
        result = calculator(num1, num2, '*')
        
        # Assert
        self.assertEqual(result, expected_result)

if __name__ == '__main__':
    unittest.main()
